

### 线程同步

```
public class Test {
    private synchronized void a() {
    }
    private void b() {
        synchronized (this) {
        }
    }
    private synchronized static void c() {
    }
    private void d() {
        synchronized (Test.class) {
        }
    }
}
同一个对象，分别调用方法a和b，锁住的是同一个对象
同一个对象，分别调用方法b和c，锁住的不是同一个对象
同一个对象，分别调用方法a、b、c，锁住的不是同一个对象
```

### 值传递与引用传递

```java
 public class Example{
	    String str=new String("good");
	    char[]ch={'a','b','c'};
	    public static void main(String args[]){
	        Example ex=new Example();
	        ex.change(ex.str,ex.ch);
	        System.out.print(ex.str+" and ");
	        System.out.print(ex.ch);
	    }
	    public void change(String str,char ch[]){
	   //引用类型变量，传递的是地址，属于引用传递。
	        str="test ok";
	        ch[0]='g';
	    }
	}
	输出：good and gbc
        
```

```
	public class Example{
	    String str=new String("tarena");
	    char[]ch={'a','b','c'};
	    public static void main(String args[]){
	        Example ex=new Example();
	        ex.change(ex.str,ex.ch);
	        System.out.print(ex.str+" and ");
	        System.out.print(ex.ch);
	    }
	    public void change(String str,char ch[]){
	   //引用类型变量，传递的是地址，属于引用传递。
	        str="test ok";
	        ch[0]='g';
	    }
	}
答：    tarena and gbc
```



### 异或运算符

```java
 public static void main(String args[]) {
	System.out.println(14^3);
	}
	^表示异或 就是相同是0 不同是1
	14是1110
	3是0011
	所以14^3=1101，即13
```

- 应用场景：寻找出现单次的元素

### 编译问题

```java
 package NowCoder;
	class Test {
	    public static void hello() {
	        System.out.println("hello");
	    }
	}
	public class MyApplication {
	    public static void main(String[] args) {
	        // TODO Auto-generated method stub
	        Test test=null;
	        test.hello();
	    }
	}
答案：能编译通过，并正确运行
```

### 构造函数的显示调用

```java
class Person {
    String name = "No name";
    public Person(String nm) {
        name = nm;
    }
}
class Employee extends Person {
    String empID = "0000";
    public Employee(String id) {
        empID = id;
    }
}
public class Test {
    public static void main(String args[]) {
        Employee e = new Employee("123");
        System.out.println(e.empID);
    }
}
结果：编译报错
/*父类没有无参的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数。*/
纠正：
 class Person {
    String name = "No name";
    public Person(String nm) {
        name = nm;
    }
     
}
class Employee extends Person {
    public Employee(String nm) {
        super(nm);
        // TODO Auto-generated constructor stub
    }
 
    String empID = "0000";
}
public class Test {
    public static void main(String args[]) {
        Employee e = new Employee("123");
        System.out.println(e.empID);
    }
}
```
### 执行顺序

```java
class X{
	    Y y=new Y();
	    public X(){
	        System.out.print("X");
	    }
	}
	class Y{
	    public Y(){
	        System.out.print("Y");
	    }
	}
	public class Z extends X{
	    Y y=new Y();
	    public Z(){
	        System.out.print("Z");
	    }
	    public static void main(String[] args) {
	        new Z();
	    }
	}
	结果：YXYZ

```



```java
class A {
	public A() {
		System.out.println("class A");// 4
	}

	{
		System.out.println("I'm A class");// 3
	}
	static {
		System.out.println("class A static");// 1
	}
}

public class B extends A {
	public B() {
		System.out.println("class B");// 6
	}

	{
		System.out.println("I'm B class");// 5
	}
	static {
		System.out.println("class B static");// 2
	}

	public static void main(String[] args) {
		new B();
	}
}
```

### ==的判断

```java
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int a = 10;
		Integer aa = 10;
		Integer aaa = Integer.valueOf("10");
		System.out.println(a == aa);// true
		System.out.println(aa == aaa);// true

		int a1 = 128;
		Integer aa1 = 128;
		Integer aaa1 = Integer.valueOf("128");
		System.out.println(a1 == aa1);// true
		System.out.println(aa1 == aaa1);// false

		String b = "ff";
		String bbb = "ff";
		System.out.println(b == bbb);// true

		String bb = new String("ff");
		System.out.println(b.equals(bb));// true
		System.out.println(b == bb);// false
        
        Integer n1 = new Integer(47);
		Integer n2 = new Integer(47);
		System.out.print(n1 == n2); //false
	}

}


	 

```






















































