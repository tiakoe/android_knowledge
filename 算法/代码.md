 <br/>

<!-- TOC -->

- [快排](#快排)
- [二分查找](#二分查找)
- [约瑟夫环](#约瑟夫环)
- [背包](#背包)
    - [01背包](#01背包)
    - [完全背包](#完全背包)
    - [多重背包问题](#多重背包问题)
- [二叉树](#二叉树)
    - [二叉树高度](#二叉树高度)
    - [二叉树节点数](#二叉树节点数)
- [众数](#众数)
- [a的n次幂对b取余](#a的n次幂对b取余)
- [排列组合](#排列组合)
- [字符串变换](#字符串变换)

<!-- /TOC -->

<br/>

### 快排

```java
	public static int[] qsort(int arr[],int start,int end) {        
	    int pivot = arr[start];        
	    int i = start;        
	    int j = end;        
	    while (i<j) {            
	        while ((i<j)&&(arr[j]>pivot)) {                
	            j--;            
	        }            
	        while ((i<j)&&(arr[i]<pivot)) {                
	            i++;            
	        }            
	        if ((arr[i]==arr[j])&&(i<j)) {                
	            i++;            
	        } else {                
	            int temp = arr[i];                
	            arr[i] = arr[j];                
	            arr[j] = temp;            
	        }        
	    }        
	    if (i-1>start) arr=qsort(arr,start,i-1);        
	    if (j+1<end) arr=qsort(arr,j+1,end);        
	    return (arr);    
	}    
	 
	public static void main(String[] args) {        
	    int arr[] = new int[]{3,3,3,7,9,122344,4656,34,34,4656,5,6,7,8,9,343,57765,23,12321};        
	    int len = arr.length-1;        
	    arr=qsort(arr,0,len);        
	    for (int i:arr) {            
	        System.out.print(i+"\t");        
	    }    
	}
```

<br/>

### 二分查找

```java

public class BinarySort {

	public static int binarySearch(Integer[] arr, int des) {
		int start = 0;
		int end = arr.length - 1;
		while (start <= end) {
			int middle = (end + start) >>> 1;
			if (des == arr[middle]) {
				return middle;
			} else if (des < arr[middle]) {
				end = middle - 1;
			} else {
				start = middle + 1;
			}
		}
		return -1;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

```

<br/>

### 约瑟夫环

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int res = 0;
		for (int i = 2; i <= n; i++) {
			res = (res + 3) % i;
		}
		System.out.println(res + 1);
	}
}
```

<br/>

### 背包

<br/>

#### 01背包

```java
	i：i个物品
	j：剩余空间大小
	
	for( int i = 1;i<=n;i++)
	{
		for (int j = 0; j <= W; j++) {
			if (j < w[i])
				dp[i][j] = dp[i - 1][j];
			else
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
		}
	}

```

<br/>

#### 完全背包

```java
dp[i][v] = max{dp[i-1][v - k * c[i]] + k * w[i] | 0 <= k * c[i]<= v}
```

<br/>

#### 多重背包问题

题目

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

思路

多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为：

```java
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}
```

<br/>

### 二叉树

<br/>

#### 二叉树高度

```java
public int getHeight(TreeNode node){
	if(node == null){
		return 0;
	}
	int i = getHeight(node.left);
	int j = getHeight(node.right);
	return (i<j)? j+1:i+1;
}
```

<br/>

#### 二叉树节点数

```java
public int getSize(TreeNode node){
	if(node == null){
	return 0;
	}
	return 1+getSize(node.left)+getSize(node.right);
}
```

<br/>

### 众数

```java
import java.util.Scanner;

public class ZhongShu {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int res = 0, t = 0;
		int[] arr = new int[] { 1, 2, 3, 4, 4, 4, 4, 6, 7, 7 };
		for (int num : arr) {
			if (t == 0) {
				res = num;
				t += 1;
			} else if (res == num) {
				t += 1;
			} else {
				t -= 1;
			}
		}
		System.out.println(res);
	}

}
```

<br/>

### a的n次幂对b取余

a^n % b
(a * b) % p = (a % p * b % p) % p
比均值：a ^ n可分为a ^（n / 2）* a ^（n / 2），可用于递归：divde和conqure。 
注意：当n为奇数时，不能将其均匀分为n / 2和n / 2。这种情况需要特殊处理：n = n / 2 + n / 2 +1;

<br/>

```java
static int fastPower(int a, int b, int n) {
		if (n == 1) {
			return a % b;
		}
		if (n == 0) {
			return 1 % b;
		}

		/**
		 * (a * b) % p = (a % p * b % p) % p 当n为奇数的时候，n = n / 2 + n / 2 +1 ；
		 */
		long product = fastPower(a, b, n / 2);
		product = (product * product) % b;
		if (n % 2 == 1) {
			product = (product * a) % b;
		}
		return (int) product;
}
```





### 排列组合

```java
import java.util.Stack;

public class Main {

	static int res = 0;
	static int m = 0;

	public static Stack<Integer> stack = new Stack<Integer>();

	public static void main(String[] args) {
		int arr[] = { 1, 2, 9, 4 };
		m = 10;
		f(arr, 4, 0);
	}

	private static void f(int[] arr, int n, int cur) {
		if (cur == n) {
			res = 0;
			for (int i : stack) {
				res += i;
			}
			if (res == m) {
				System.out.println(stack);
			}
			return;
		}

		for (int i = 0; i < arr.length; i++) {
			stack.add(arr[i]);
			f(arr, n, cur + 1);
			stack.pop();
		}
	}

}

```



### 字符串变换

给定一个长度为n只包含0,1,2三种字符的字符串.你能够对字符串中的字符进行替换,但是不能添加和删除.现在希望使得字符串中0,1,2的个数相等.在保证最少替换次数的前提下,得到的字典序最小的字符串是多少?

输入: 一个可以被3整除的整数n,长度为n只包含0,1,2的字符串.(3<=n<=300000)

输出: 在保证最少替换次数的前提下,字典序最小的字符串.

样例1

Input:

6

000000

 

Output:

001122

 

样例2

Input:

6

120110

 

Output:

120120



```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class Main {

	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		String s1 = in.next();
		if (s1.length() != n) {
			return;
		}

		int[] num = new int[3];

		String t = s1.replaceAll("0", "");
		num[0] = s1.length() - t.length();

		t = s1.replaceAll("1", "");
		num[1] = s1.length() - t.length();

		t = s1.replaceAll("2", "");
		num[2] = s1.length() - t.length();

		int m = n / 3;
		char[] arr = s1.toCharArray();
		ArrayList<Integer> aList = new ArrayList<>();
		int flag = 0;
		if (num[0] > m) {
			flag = num[0] - m;
			for (int i = arr.length - 1; i > 0; i--) {
				if (arr[i] == '0') {
					aList.add(i);
					flag--;
					if (flag == 0) {
						break;
					}
				}
			}
		}
		if (num[2] > m) {
			flag = num[2] - m;
			for (int i = 0; i < arr.length; i++) {
				if (arr[i] == '2') {
					aList.add(i);
					flag--;
					if (flag == 0) {
						break;
					}
				}
			}
		}
		if (num[1] > m && num[2] < m) {
			flag = Math.min(num[1] - m, m - num[2]);
			for (int i = arr.length - 1; i > 0; i--) {
				if (arr[i] == '1') {
					aList.add(i);
					flag--;
					if (flag == 0) {
						break;
					}
				}
			}
		}
		if (num[1] > m && num[0] < m) {
			flag = Math.min(num[1] - m, m - num[0]);
			for (int i = 0; i < arr.length; i++) {
				if (arr[i] == '1') {
					aList.add(i);
					flag--;
					if (flag == 0) {
						break;
					}
				}
			}
		}

		Collections.sort(aList);
		for (int i = 0; i < aList.size(); i++) {
			for (int j = 0; j < num.length; j++) {
				if (num[j] < m) {
					arr[aList.get(i)] = (char) (j + 48);
					num[j]++;
					break;
				}
			}
		}

		for (char i : arr) {
			System.out.print(i);
		}
		System.out.println();
	}

}
```







































