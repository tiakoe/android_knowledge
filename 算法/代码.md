

[TOC]



### 快排

```java
	public static int[] qsort(int arr[],int start,int end) {        
	    int pivot = arr[start];        
	    int i = start;        
	    int j = end;        
	    while (i<j) {            
	        while ((i<j)&&(arr[j]>pivot)) {                
	            j--;            
	        }            
	        while ((i<j)&&(arr[i]<pivot)) {                
	            i++;            
	        }            
	        if ((arr[i]==arr[j])&&(i<j)) {                
	            i++;            
	        } else {                
	            int temp = arr[i];                
	            arr[i] = arr[j];                
	            arr[j] = temp;            
	        }        
	    }        
	    if (i-1>start) arr=qsort(arr,start,i-1);        
	    if (j+1<end) arr=qsort(arr,j+1,end);        
	    return (arr);    
	}    
	 
	public static void main(String[] args) {        
	    int arr[] = new int[]{3,3,3,7,9,122344,4656,34,34,4656,5,6,7,8,9,343,57765,23,12321};        
	    int len = arr.length-1;        
	    arr=qsort(arr,0,len);        
	    for (int i:arr) {            
	        System.out.print(i+"\t");        
	    }    
	}
```

### 二分查找

```java

public class BinarySort {

	public static int binarySearch(Integer[] arr, int des) {
		int start = 0;
		int end = arr.length - 1;
		while (start <= end) {
			int middle = (end + start) >>> 1;
			if (des == arr[middle]) {
				return middle;
			} else if (des < arr[middle]) {
				end = middle - 1;
			} else {
				start = middle + 1;
			}
		}
		return -1;
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

```

### 约瑟夫环

```java
import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int res = 0;
		for (int i = 2; i <= n; i++) {
			res = (res + 3) % i;
		}
		System.out.println(res + 1);
	}
}
```



### 背包

#### 01背包

```java
	i：i个物品
	j：剩余空间大小
	
	for( int i = 1;i<=n;i++)
	{
		for (int j = 0; j <= W; j++) {
			if (j < w[i])
				dp[i][j] = dp[i - 1][j];
			else
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
		}
	}

```



#### 完全背包

```java
dp[i][v] = max{dp[i-1][v - k * c[i]] + k * w[i] | 0 <= k * c[i]<= v}
```



#### 多重背包问题

题目

有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大

思路

多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为：

```java
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k<=n[i]}
```



### 二叉树

#### 二叉树高度

```java
public int getHeight(TreeNode node){
	if(node == null){
		return 0;
	}
	int i = getHeight(node.left);
	int j = getHeight(node.right);
	return (i<j)? j+1:i+1;
}
```

#### 二叉树节点数

```java
public int getSize(TreeNode node){
	if(node == null){
	return 0;
	}
	return 1+getSize(node.left)+getSize(node.right);
}
```



### 众数

```java
import java.util.Scanner;

public class ZhongShu {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int res = 0, t = 0;
		int[] arr = new int[] { 1, 2, 3, 4, 4, 4, 4, 6, 7, 7 };
		for (int num : arr) {
			if (t == 0) {
				res = num;
				t += 1;
			} else if (res == num) {
				t += 1;
			} else {
				t -= 1;
			}
		}
		System.out.println(res);
	}

}
```



### 计算a^n % b

(a * b) % p = (a % p * b % p) % p
比均值：a ^ n可分为a ^（n / 2）* a ^（n / 2），可用于递归：divde和conqure。 
注意：当n为奇数时，不能将其均匀分为n / 2和n / 2。这种情况需要特殊处理：n = n / 2 + n / 2 +1;

```java
static int fastPower(int a, int b, int n) {
		if (n == 1) {
			return a % b;
		}
		if (n == 0) {
			return 1 % b;
		}

		/**
		 * (a * b) % p = (a % p * b % p) % p 当n为奇数的时候，n = n / 2 + n / 2 +1 ；
		 */
		long product = fastPower(a, b, n / 2);
		product = (product * product) % b;
		if (n % 2 == 1) {
			product = (product * a) % b;
		}
		return (int) product;
}
```



### 无向图总路程

给定一张包含N个点、N-1条边的无向连通图，节点从1到N编号，每条边的长度均为1。假设你从1号节点出发并打算遍历所有节点，那么总路程至少是多少？

输入描述:

第一行包含一个整数N，1≤N≤10^5。

接下来N-1行，每行包含两个整数X和Y，表示X号节点和Y号节点之间有一条边，1≤X，Y≤N。



输出描述:

输出总路程的最小值。

 

输入例子1:

4

1 2

1 3

3 4

 

输出例子1:

4

```c++
#include <bits/stdc++.h>
using namespace std;
 
int sum = 0;
const int N = 100003;
vector<int> v[N];
 
void DFS(int x, int pre, int w){
    for(int i=0;i<v[x].size();i++){
        if(v[x][i]!=pre)
            DFS(v[x][i], x, w+1);
    }
    sum = max(sum, w);
}
 
int main(){
    int n,x,y;
    cin>>n;
    for(int i=1;i<=n-1;i++){
        cin>>x>>y;
        v[x].push_back(y);
        v[y].push_back(x);
    }
    DFS(1, -1, 0);
    cout<<2*(n-1)-sum<<endl;
    return 0;
}

```



